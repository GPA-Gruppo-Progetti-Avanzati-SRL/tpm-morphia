package {{ .Collection.GetPackageName }}

import (
	"fmt"
	"time"
	"go.mongodb.org/mongo-driver/bson"
)

func FilterGoInfo() string {
	i := fmt.Sprintf("tpm_morphia query filter support generated for %s package on %s", "author", time.Now().String())
	return i
}

type Criterion func() bson.E
type Criteria []Criterion

type Filter struct {
	listOfCriteria []Criteria
}

func (f *Filter)or() *Criteria {
	ca := make(Criteria, 0)

	/*
	 * Note: the array gets allocated to avoid some nasty problem related to the fact that the underlying array can be moved
	 * when needs to make room. In this case if somebody write something like this:

		f = Filter{}
		ca := f.or().lastNameEqTo("Smith").firstNameEqTo("Colin")
		f.or().firstNameEqTo("John")
		ca.books().titleEq("My Best Seller")

	 * and saves the variable ca to be reused what happens is that the second f.or() causes the listOfCriteria
	 * array to be moved and that slice is dead as to speak.
	 * Anyway, best option would be not to interleave the conditions between or() calls.
	 */
	if len(f.listOfCriteria) == 0 {
	   f.listOfCriteria = make([]Criteria, 0, 5)
	}

	// Should check top criteria if empty...
	f.listOfCriteria = append(f.listOfCriteria, ca)
	return &f.listOfCriteria[len(f.listOfCriteria) - 1]
}

var emptyFilter = bson.D{}

func (f *Filter)build() bson.D {

	if len(f.listOfCriteria) == 0 {
		return emptyFilter
	}

	docA := bson.A{}
	for _, cas := range f.listOfCriteria {
		doc := bson.D{}
		for _, c := range cas {
			doc = append(doc, c())
		}
		docA = append(docA, doc)
	}

	if len(docA) == 1 {
		return docA[0].(bson.D)
	}

	return bson.D{ { "$or", docA }}
}


{{range $a := .Collection.DirectAttributes}}
{{- if and $a.GetDefinition.Queryable (eq $a.GetDefinition.Typ "string") }}
{{ template "filter-string" filterSubTemplateContext $a "*" }}
{{- end -}}
{{- if and $a.GetDefinition.Queryable (eq $a.GetDefinition.Typ "int") }}
{{ template "filter-int" filterSubTemplateContext $a "*" }}
{{- end -}}
{{- if and $a.GetDefinition.Queryable (eq $a.GetDefinition.Typ "array") }}
{{- if eq $a.Item.GetDefinition.Typ "string" }}
{{ template "filter-string" filterSubTemplateContext $a "*" }}
{{- end -}}
{{- if eq $a.Item.GetDefinition.Typ "int" }}
{{ template "filter-int" filterSubTemplateContext $a "*" }}
{{- end -}}
{{- end -}}
{{- end -}}

{{range $s := .Collection.GetStructAttributes}}
// {{$s.GetName false}} struct: {{$s.GetDefinition.StructName}}
type {{$s.GetDefinition.StructName}}Criteria struct {
	criteria *Criteria
}

{{- if ne ($s.GetName false) "[]" }}
func (ca *Criteria) {{$s.GetName false}}() {{$s.GetDefinition.StructName}}Criteria {
	return {{$s.GetDefinition.StructName}}Criteria{ criteria: ca}
}
{{else}}
func (ca *Criteria) {{$s.GetParent.GetName false}}() {{$s.GetDefinition.StructName}}Criteria {
	return {{$s.GetDefinition.StructName}}Criteria{ criteria: ca}
}
{{end }}

{{- range $sa := $s.Attributes}}
// {{$sa.GetName true}}
{{- if and $sa.GetDefinition.Queryable (eq $sa.GetDefinition.Typ "string") }}
{{ template "struct-filter-string" filterSubTemplateContext $sa $s.GetDefinition.StructName }}
{{- end -}}
{{- if and $sa.GetDefinition.Queryable (eq $sa.GetDefinition.Typ "int") }}
{{ template "struct-filter-int" filterSubTemplateContext $sa $s.GetDefinition.StructName }}
{{- end -}}
{{- if and $sa.GetDefinition.Queryable (eq $sa.GetDefinition.Typ "array") }}
{{- if eq $sa.Item.GetDefinition.Typ "string" }}
{{ template "struct-filter-string" filterSubTemplateContext $sa $s.GetParent.GetDefinition.StructName }}
{{end }}
{{- if eq $sa.Item.GetDefinition.Typ "int" }}
{{ template "struct-filter-int" filterSubTemplateContext $sa $s.GetParent.GetDefinition.StructName }}
{{end }}
{{end }}
{{end }}
{{end }}
